   1               		.file	"stack.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 118               		.section	.text.stack_init,"ax",@progbits
 120               	.global	stack_init
 122               	stack_init:
 123               		.stabd	46,0,0
   1:stack.c       **** /*----------------------------------------------------------------------------
   2:stack.c       ****  Copyright:      Radig Ulrich  mailto: mail@ulrichradig.de
   3:stack.c       ****  Author:         Radig Ulrich
   4:stack.c       ****  Remarks:
   5:stack.c       ****  known Problems: none
   6:stack.c       ****  Version:        18.01.2009
   7:stack.c       ****  Description:    Ethernet Stack,
   8:stack.c       ****  				 simplified for use in a bootloader by Jens Mundhenke
   9:stack.c       **** 
  10:stack.c       ****  Dieses Programm ist freie Software. Sie können es unter den Bedingungen der
  11:stack.c       ****  GNU General Public License, wie von der Free Software Foundation veröffentlicht,
  12:stack.c       ****  weitergeben und/oder modifizieren, entweder gemäß Version 2 der Lizenz oder
  13:stack.c       ****  (nach Ihrer Option) jeder späteren Version.
  14:stack.c       **** 
  15:stack.c       ****  Die Veröffentlichung dieses Programms erfolgt in der Hoffnung,
  16:stack.c       ****  daß es Ihnen von Nutzen sein wird, aber OHNE IRGENDEINE GARANTIE,
  17:stack.c       ****  sogar ohne die implizite Garantie der MARKTREIFE oder der VERWENDBARKEIT
  18:stack.c       ****  FÜR EINEN BESTIMMTEN ZWECK. Details finden Sie in der GNU General Public License.
  19:stack.c       **** 
  20:stack.c       ****  Sie sollten eine Kopie der GNU General Public License zusammen mit diesem
  21:stack.c       ****  Programm erhalten haben.
  22:stack.c       ****  Falls nicht, schreiben Sie an die Free Software Foundation,
  23:stack.c       ****  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
  24:stack.c       **** ------------------------------------------------------------------------------*/
  25:stack.c       **** 
  26:stack.c       **** #include "para.h"
  27:stack.c       **** #include "stack.h"
  28:stack.c       **** #include "bootloader/tftp.h"
  29:stack.c       **** #include "config.h"
  30:stack.c       **** #include "usart.h"
  31:stack.c       **** 
  32:stack.c       **** // dont forget to enable usart in config.h
  33:stack.c       **** //#define DEBUG usart_write	//mit Debugausgabe
  34:stack.c       **** #define DEBUG(...) 			//ohne Debugausgabe
  35:stack.c       **** 
  36:stack.c       **** unsigned char myip[4];
  37:stack.c       **** 
  38:stack.c       **** unsigned int IP_id_counter = 0;
  39:stack.c       **** 
  40:stack.c       **** unsigned char eth_buffer[MTU_SIZE+1];
  41:stack.c       **** 
  42:stack.c       **** struct arp_table arp_entry[MAX_ARP_ENTRY];
  43:stack.c       **** 
  44:stack.c       **** 
  45:stack.c       **** //----------------------------------------------------------------------------
  46:stack.c       **** //Trägt Anwendung in Anwendungsliste ein
  47:stack.c       **** void stack_init (void)
  48:stack.c       **** {
 125               	.LM0:
 126               	.LFBB1:
 127 0000 CF93      		push r28
 128 0002 DF93      		push r29
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 2 */
 132               	.L__stack_usage = 2
  49:stack.c       **** 	//Timer starten
  50:stack.c       **** 	timer_init();
 134               	.LM1:
 135 0004 0E94 0000 		call timer_init
  51:stack.c       **** 
  52:stack.c       **** #if USE_PARAMETERS_FROM_EEPROM
  53:stack.c       **** 	//IP, NETMASK und ROUTER_IP aus EEPROM auslesen
  54:stack.c       ****     (*((unsigned long*)&myip[0])) = para_getip(IP_EEPROM_STORE,MYIP);
  55:stack.c       **** 
  56:stack.c       **** 	//MAC Adresse setzen
  57:stack.c       **** 	if ( para_getchar(MAC_EEPROM_STORE) != 0xFF )
  58:stack.c       **** 		for ( int i=0; i<6; i++ )
  59:stack.c       **** 			mymac[i] = para_getchar(MAC_EEPROM_STORE+i);
  60:stack.c       **** #else
  61:stack.c       ****     (*((unsigned long*)&myip[0])) = MYIP;
 137               	.LM2:
 138 0008 80EC      		ldi r24,lo8(1510058176)
 139 000a 98EA      		ldi r25,hi8(1510058176)
 140 000c A1E0      		ldi r26,hlo8(1510058176)
 141 000e BAE5      		ldi r27,hhi8(1510058176)
 142 0010 8093 0000 		sts myip,r24
 143 0014 9093 0000 		sts myip+1,r25
 144 0018 A093 0000 		sts myip+2,r26
 145 001c B093 0000 		sts myip+3,r27
  62:stack.c       **** #endif
  63:stack.c       **** 
  64:stack.c       **** 	/*NIC Initialisieren*/
  65:stack.c       **** 	DEBUG_WRITE("\n\rNIC init:");
  66:stack.c       **** 	ETH_INIT();
 147               	.LM3:
 148 0020 0E94 0000 		call enc28j60_init
  67:stack.c       **** 	DEBUG_WRITE("Ok\r\n");
  68:stack.c       **** 
  69:stack.c       **** #if USE_ENC28J60
  70:stack.c       **** 	ETH_PACKET_SEND(60,eth_buffer);
 150               	.LM4:
 151 0024 C0E0      		ldi r28,lo8(eth_buffer)
 152 0026 D0E0      		ldi r29,hi8(eth_buffer)
 153 0028 8CE3      		ldi r24,lo8(60)
 154 002a 90E0      		ldi r25,hi8(60)
 155 002c BE01      		movw r22,r28
 156 002e 0E94 0000 		call enc28j60_send_packet
  71:stack.c       **** 	ETH_PACKET_SEND(60,eth_buffer);
 158               	.LM5:
 159 0032 8CE3      		ldi r24,lo8(60)
 160 0034 90E0      		ldi r25,hi8(60)
 161 0036 BE01      		movw r22,r28
 162 0038 0E94 0000 		call enc28j60_send_packet
 163               	/* epilogue start */
  72:stack.c       **** #endif
  73:stack.c       **** 
  74:stack.c       **** 	DEBUG_WRITE("My IP: %1i.%1i.%1i.%1i\r\n\r\n",myip[0],myip[1],myip[2],myip[3]);
  75:stack.c       **** }
 165               	.LM6:
 166 003c DF91      		pop r29
 167 003e CF91      		pop r28
 168 0040 0895      		ret
 170               	.Lscope1:
 172               		.stabd	78,0,0
 173               		.section	.text.arp_entry_add,"ax",@progbits
 175               	.global	arp_entry_add
 177               	arp_entry_add:
 178               		.stabd	46,0,0
  76:stack.c       **** 
  77:stack.c       **** 
  78:stack.c       **** //----------------------------------------------------------------------------
  79:stack.c       **** //ETH get data
  80:stack.c       **** void eth_get_data (void)
  81:stack.c       **** {
  82:stack.c       **** 	unsigned int packet_lenght;
  83:stack.c       **** 
  84:stack.c       **** 	packet_lenght = ETH_PACKET_RECEIVE(MTU_SIZE,eth_buffer);
  85:stack.c       **** 	/*Wenn ein Packet angekommen ist, ist packet_lenght =! 0*/
  86:stack.c       **** 	if(packet_lenght > 0)
  87:stack.c       **** 	{
  88:stack.c       **** 		packet_lenght = packet_lenght - 4;
  89:stack.c       **** 		eth_buffer[packet_lenght+1] = 0;
  90:stack.c       **** 		eth_len = packet_lenght;			// remember length for global access
  91:stack.c       **** 		check_packet();
  92:stack.c       **** 	}
  93:stack.c       **** 
  94:stack.c       **** 
  95:stack.c       **** }
  96:stack.c       **** 
  97:stack.c       **** 
  98:stack.c       **** //----------------------------------------------------------------------------
  99:stack.c       **** //Check Packet and call Stack for TCP or UDP
 100:stack.c       **** void check_packet (void)
 101:stack.c       **** {
 102:stack.c       **** 	//Pointer auf Ethernet_Header
 103:stack.c       **** 	struct Ethernet_Header *ethernet;
 104:stack.c       **** 	ethernet = (struct Ethernet_Header *)&eth_buffer[ETHER_OFFSET];
 105:stack.c       **** 
 106:stack.c       **** 	//Pointer auf IP_Header
 107:stack.c       **** 	struct IP_Header *ip;
 108:stack.c       **** 	ip = (struct IP_Header *)&eth_buffer[IP_OFFSET];
 109:stack.c       **** #if USE_PING
 110:stack.c       **** 	//Pointer auf ICMP_Header
 111:stack.c       **** 	struct ICMP_Header *icmp;
 112:stack.c       **** 	icmp = (struct ICMP_Header *)&eth_buffer[ICMP_OFFSET];
 113:stack.c       **** #endif
 114:stack.c       **** 
 115:stack.c       **** 	if(ETHERNET_ARP_DATAGRAMM) {
 116:stack.c       **** 		//Erzeugt ein ARP Reply Packet
 117:stack.c       **** 		arp_reply();
 118:stack.c       **** 	} else {
 119:stack.c       **** 		if(ETHERNET_IP_DATAGRAMM && IF_MYIP) {
 120:stack.c       **** 			arp_entry_add();			//Refresh des ARP Eintrages
 121:stack.c       **** #if USE_PING
 122:stack.c       **** 			//Ist protokoll Byte = 1 dann ist es ein ICMP Packet
 123:stack.c       **** 			if(IP_ICMP_PACKET) {
 124:stack.c       **** 				switch ( icmp->ICMP_Type ) {
 125:stack.c       **** 				case (0x08):
 126:stack.c       **** 					//Echo-Request empfangen, erzeugen eines ICMP Reply Packet (PING Echo)
 127:stack.c       **** 					icmp_send(ip->IP_Srcaddr,0x00,0x00,icmp->ICMP_SeqNum,icmp->ICMP_Id);
 128:stack.c       **** 					break;
 129:stack.c       **** 				case (0x00):
 130:stack.c       **** 					//Echo-Reply Packet empfangen, Empfang melden
 131:stack.c       **** 					//TODO: Erst Sequenznummer vergleichen?, Zeitmessung?
 132:stack.c       **** 					DEBUG_WRITE("%i",(ip->IP_Srcaddr&0x000000FF));
 133:stack.c       **** 					DEBUG_WRITE(".%i",((ip->IP_Srcaddr&0x0000FF00)>>8));
 134:stack.c       **** 					DEBUG_WRITE(".%i",((ip->IP_Srcaddr&0x00FF0000)>>16));
 135:stack.c       **** 					DEBUG_WRITE(".%i",((ip->IP_Srcaddr&0xFF000000)>>24));
 136:stack.c       **** 					DEBUG_WRITE(": PONG!\r\n");
 137:stack.c       **** 					break;
 138:stack.c       **** 				}
 139:stack.c       **** 				return;
 140:stack.c       **** 			}
 141:stack.c       **** 			else
 142:stack.c       **** #endif
 143:stack.c       **** 			{
 144:stack.c       **** 				if(IP_UDP_PACKET) udp_socket_process();
 145:stack.c       **** 			}
 146:stack.c       **** 		}
 147:stack.c       **** 	}
 148:stack.c       **** 	return;
 149:stack.c       **** }
 150:stack.c       **** 
 151:stack.c       **** //----------------------------------------------------------------------------
 152:stack.c       **** //erzeugt einen ARP - Eintrag wenn noch nicht vorhanden
 153:stack.c       **** void arp_entry_add (void)
 154:stack.c       **** {
 180               	.LM7:
 181               	.LFBB2:
 182 0000 CF93      		push r28
 183 0002 DF93      		push r29
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 2 */
 187               	.L__stack_usage = 2
 188               	.LBB2:
 155:stack.c       **** 	struct Ethernet_Header *ethernet;
 156:stack.c       **** 	ethernet = (struct Ethernet_Header *)&eth_buffer[ETHER_OFFSET];
 157:stack.c       **** 
 158:stack.c       **** 	struct ARP_Header *arp;
 159:stack.c       **** 	arp = (struct ARP_Header *)&eth_buffer[ARP_OFFSET];
 160:stack.c       **** 
 161:stack.c       **** 	struct IP_Header *ip;
 162:stack.c       **** 	ip = (struct IP_Header *)&eth_buffer[IP_OFFSET];
 163:stack.c       **** 
 164:stack.c       **** 	//Eintrag schon vorhanden?
 165:stack.c       **** 	for (unsigned char a = 0;a<MAX_ARP_ENTRY;a++)
 166:stack.c       **** 	{
 167:stack.c       **** 		if(ETHERNET_ARP_DATAGRAMM)
 190               	.LM8:
 191 0004 6091 0000 		lds r22,eth_buffer+12
 192 0008 7091 0000 		lds r23,eth_buffer+12+1
 193 000c C0E0      		ldi r28,lo8(arp_entry+6)
 194 000e D0E0      		ldi r29,hi8(arp_entry+6)
 195               	.LBE2:
 153:stack.c       **** void arp_entry_add (void)
 197               	.LM9:
 198 0010 FE01      		movw r30,r28
 199               	.L6:
 200               	.LBB3:
 202               	.LM10:
 203 0012 86E0      		ldi r24,hi8(1544)
 204 0014 6830      		cpi r22,lo8(1544)
 205 0016 7807      		cpc r23,r24
 206 0018 01F4      		brne .L3
 168:stack.c       **** 		{
 169:stack.c       **** 			if(arp_entry[a].arp_t_ip == arp->ARP_SIPAddr)
 208               	.LM11:
 209 001a 2081      		ld r18,Z
 210 001c 3181      		ldd r19,Z+1
 211 001e 4281      		ldd r20,Z+2
 212 0020 5381      		ldd r21,Z+3
 213 0022 8091 0000 		lds r24,eth_buffer+28
 214 0026 9091 0000 		lds r25,eth_buffer+28+1
 215 002a A091 0000 		lds r26,eth_buffer+28+2
 216 002e B091 0000 		lds r27,eth_buffer+28+3
 217 0032 00C0      		rjmp .L16
 218               	.L3:
 170:stack.c       **** 			{
 171:stack.c       **** 			return;
 172:stack.c       **** 			}
 173:stack.c       **** 		}
 174:stack.c       **** 		if(ETHERNET_IP_DATAGRAMM)
 220               	.LM12:
 221 0034 6830      		cpi r22,8
 222 0036 7105      		cpc r23,__zero_reg__
 223 0038 01F4      		brne .L5
 175:stack.c       **** 		{
 176:stack.c       **** 			if(arp_entry[a].arp_t_ip == ip->IP_Srcaddr)
 225               	.LM13:
 226 003a 2081      		ld r18,Z
 227 003c 3181      		ldd r19,Z+1
 228 003e 4281      		ldd r20,Z+2
 229 0040 5381      		ldd r21,Z+3
 230 0042 8091 0000 		lds r24,eth_buffer+26
 231 0046 9091 0000 		lds r25,eth_buffer+26+1
 232 004a A091 0000 		lds r26,eth_buffer+26+2
 233 004e B091 0000 		lds r27,eth_buffer+26+3
 234               	.L16:
 235 0052 2817      		cp r18,r24
 236 0054 3907      		cpc r19,r25
 237 0056 4A07      		cpc r20,r26
 238 0058 5B07      		cpc r21,r27
 239 005a 01F4      		brne .+2
 240 005c 00C0      		rjmp .L2
 241               	.L5:
 242 005e 3A96      		adiw r30,10
 165:stack.c       **** 	for (unsigned char a = 0;a<MAX_ARP_ENTRY;a++)
 244               	.LM14:
 245 0060 80E0      		ldi r24,hi8(arp_entry+56)
 246 0062 E030      		cpi r30,lo8(arp_entry+56)
 247 0064 F807      		cpc r31,r24
 248 0066 01F4      		brne .L6
 249 0068 20E0      		ldi r18,lo8(0)
 250 006a 30E0      		ldi r19,hi8(0)
 251               	.L11:
 252 006c 522F      		mov r21,r18
 253 006e 432F      		mov r20,r19
 254               	.LBE3:
 255               	.LBB4:
 177:stack.c       **** 			{
 178:stack.c       **** 			return;
 179:stack.c       **** 			}
 180:stack.c       **** 		}
 181:stack.c       **** 	}
 182:stack.c       **** 
 183:stack.c       **** 	//Freien Eintrag finden
 184:stack.c       **** 	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
 185:stack.c       **** 	{
 186:stack.c       **** 		if(arp_entry[b].arp_t_ip == 0)
 257               	.LM15:
 258 0070 8881      		ld r24,Y
 259 0072 9981      		ldd r25,Y+1
 260 0074 AA81      		ldd r26,Y+2
 261 0076 BB81      		ldd r27,Y+3
 262 0078 0097      		sbiw r24,0
 263 007a A105      		cpc r26,__zero_reg__
 264 007c B105      		cpc r27,__zero_reg__
 265 007e 01F0      		breq .+2
 266 0080 00C0      		rjmp .L7
 187:stack.c       **** 		{
 188:stack.c       **** 			if(ETHERNET_ARP_DATAGRAMM)
 268               	.LM16:
 269 0082 86E0      		ldi r24,hi8(1544)
 270 0084 6830      		cpi r22,lo8(1544)
 271 0086 7807      		cpc r23,r24
 272 0088 01F4      		brne .L8
 153:stack.c       **** void arp_entry_add (void)
 274               	.LM17:
 275 008a A0E0      		ldi r26,lo8(eth_buffer+6)
 276 008c B0E0      		ldi r27,hi8(eth_buffer+6)
 277 008e C901      		movw r24,r18
 278 0090 FC01      		movw r30,r24
 279 0092 EE0F      		lsl r30
 280 0094 FF1F      		rol r31
 281 0096 23E0      		ldi r18,3
 282 0098 880F      	1:	lsl r24
 283 009a 991F      		rol r25
 284 009c 2A95      		dec r18
 285 009e 01F4      		brne 1b
 286 00a0 E80F      		add r30,r24
 287 00a2 F91F      		adc r31,r25
 288 00a4 E050      		subi r30,lo8(-(arp_entry))
 289 00a6 F040      		sbci r31,hi8(-(arp_entry))
 290               	.LBE4:
 291               	.LBB7:
 292 00a8 86E0      		ldi r24,lo8(6)
 293               	.L9:
 294               	.LBE7:
 295               	.LBB8:
 296               	.LBB5:
 189:stack.c       **** 			{
 190:stack.c       **** 				for(unsigned char a = 0; a < 6; a++)
 191:stack.c       **** 				{
 192:stack.c       **** 					arp_entry[b].arp_t_mac[a] = ethernet->EnetPacketSrc[a];
 298               	.LM18:
 299 00aa 9D91      		ld r25,X+
 300 00ac 9193      		st Z+,r25
 301 00ae 8150      		subi r24,lo8(-(-1))
 190:stack.c       **** 				for(unsigned char a = 0; a < 6; a++)
 303               	.LM19:
 304 00b0 01F4      		brne .L9
 305               	.LBE5:
 193:stack.c       **** 				}
 194:stack.c       **** 				arp_entry[b].arp_t_ip = arp->ARP_SIPAddr;
 307               	.LM20:
 308 00b2 852F      		mov r24,r21
 309 00b4 942F      		mov r25,r20
 310 00b6 FC01      		movw r30,r24
 311 00b8 EE0F      		lsl r30
 312 00ba FF1F      		rol r31
 313 00bc A3E0      		ldi r26,3
 314 00be 880F      	1:	lsl r24
 315 00c0 991F      		rol r25
 316 00c2 AA95      		dec r26
 317 00c4 01F4      		brne 1b
 318 00c6 E80F      		add r30,r24
 319 00c8 F91F      		adc r31,r25
 320 00ca E050      		subi r30,lo8(-(arp_entry))
 321 00cc F040      		sbci r31,hi8(-(arp_entry))
 322 00ce 8091 0000 		lds r24,eth_buffer+28
 323 00d2 9091 0000 		lds r25,eth_buffer+28+1
 324 00d6 A091 0000 		lds r26,eth_buffer+28+2
 325 00da B091 0000 		lds r27,eth_buffer+28+3
 326 00de 00C0      		rjmp .L17
 327               	.L8:
 195:stack.c       **** 				return;
 196:stack.c       **** 			}
 197:stack.c       **** 			if(ETHERNET_IP_DATAGRAMM)
 329               	.LM21:
 330 00e0 6830      		cpi r22,8
 331 00e2 7105      		cpc r23,__zero_reg__
 332 00e4 01F4      		brne .L2
 153:stack.c       **** void arp_entry_add (void)
 334               	.LM22:
 335 00e6 A0E0      		ldi r26,lo8(eth_buffer+6)
 336 00e8 B0E0      		ldi r27,hi8(eth_buffer+6)
 337 00ea C901      		movw r24,r18
 338 00ec FC01      		movw r30,r24
 339 00ee EE0F      		lsl r30
 340 00f0 FF1F      		rol r31
 341 00f2 63E0      		ldi r22,3
 342 00f4 880F      	1:	lsl r24
 343 00f6 991F      		rol r25
 344 00f8 6A95      		dec r22
 345 00fa 01F4      		brne 1b
 346 00fc E80F      		add r30,r24
 347 00fe F91F      		adc r31,r25
 348 0100 E050      		subi r30,lo8(-(arp_entry))
 349 0102 F040      		sbci r31,hi8(-(arp_entry))
 350               	.LBE8:
 351               	.LBB9:
 352 0104 86E0      		ldi r24,lo8(6)
 353               	.L10:
 354               	.LBE9:
 355               	.LBB10:
 356               	.LBB6:
 198:stack.c       **** 			{
 199:stack.c       **** 				for(unsigned char a = 0; a < 6; a++)
 200:stack.c       **** 				{
 201:stack.c       **** 					arp_entry[b].arp_t_mac[a] = ethernet->EnetPacketSrc[a];
 358               	.LM23:
 359 0106 9D91      		ld r25,X+
 360 0108 9193      		st Z+,r25
 361 010a 8150      		subi r24,lo8(-(-1))
 199:stack.c       **** 				for(unsigned char a = 0; a < 6; a++)
 363               	.LM24:
 364 010c 01F4      		brne .L10
 365               	.LBE6:
 202:stack.c       **** 				}
 203:stack.c       **** 				arp_entry[b].arp_t_ip = ip->IP_Srcaddr;
 367               	.LM25:
 368 010e 852F      		mov r24,r21
 369 0110 942F      		mov r25,r20
 370 0112 FC01      		movw r30,r24
 371 0114 EE0F      		lsl r30
 372 0116 FF1F      		rol r31
 373 0118 23E0      		ldi r18,3
 374 011a 880F      	1:	lsl r24
 375 011c 991F      		rol r25
 376 011e 2A95      		dec r18
 377 0120 01F4      		brne 1b
 378 0122 E80F      		add r30,r24
 379 0124 F91F      		adc r31,r25
 380 0126 E050      		subi r30,lo8(-(arp_entry))
 381 0128 F040      		sbci r31,hi8(-(arp_entry))
 382 012a 8091 0000 		lds r24,eth_buffer+26
 383 012e 9091 0000 		lds r25,eth_buffer+26+1
 384 0132 A091 0000 		lds r26,eth_buffer+26+2
 385 0136 B091 0000 		lds r27,eth_buffer+26+3
 386               	.L17:
 387 013a 8683      		std Z+6,r24
 388 013c 9783      		std Z+7,r25
 389 013e A087      		std Z+8,r26
 390 0140 B187      		std Z+9,r27
 204:stack.c       **** 				return;
 392               	.LM26:
 393 0142 00C0      		rjmp .L2
 394               	.L7:
 395 0144 2F5F      		subi r18,lo8(-(1))
 396 0146 3F4F      		sbci r19,hi8(-(1))
 397 0148 2A96      		adiw r28,10
 184:stack.c       **** 	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
 399               	.LM27:
 400 014a 2530      		cpi r18,5
 401 014c 3105      		cpc r19,__zero_reg__
 402 014e 01F0      		breq .+2
 403 0150 00C0      		rjmp .L11
 404               	.L2:
 405               	/* epilogue start */
 406               	.LBE10:
 205:stack.c       **** 			}
 206:stack.c       **** 
 207:stack.c       **** 		DEBUG("No ARP/IP packet!\r\n");
 208:stack.c       **** 		return;
 209:stack.c       **** 		}
 210:stack.c       **** 	}
 211:stack.c       **** 	//Eintrag konnte nicht mehr aufgenommen werden
 212:stack.c       **** 	DEBUG("ARP table full!\r\n");
 213:stack.c       **** 	return;
 214:stack.c       **** }
 408               	.LM28:
 409 0152 DF91      		pop r29
 410 0154 CF91      		pop r28
 411 0156 0895      		ret
 413               	.Lscope2:
 415               		.stabd	78,0,0
 416               		.section	.text.arp_entry_search,"ax",@progbits
 419               	.global	arp_entry_search
 421               	arp_entry_search:
 422               		.stabd	46,0,0
 215:stack.c       **** 
 216:stack.c       **** //----------------------------------------------------------------------------
 217:stack.c       **** //Diese Routine such anhand der IP den ARP eintrag
 218:stack.c       **** char arp_entry_search (unsigned long dest_ip)
 219:stack.c       **** {
 424               	.LM29:
 425               	.LFBB3:
 426               	/* prologue: function */
 427               	/* frame size = 0 */
 428               	/* stack size = 0 */
 429               	.L__stack_usage = 0
 220:stack.c       **** 	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
 431               	.LM30:
 432 0000 E0E0      		ldi r30,lo8(arp_entry+6)
 433 0002 F0E0      		ldi r31,hi8(arp_entry+6)
 434 0004 A0E0      		ldi r26,lo8(0)
 435               	.L20:
 436               	.LBB11:
 221:stack.c       **** 	{
 222:stack.c       **** 		if(arp_entry[b].arp_t_ip == dest_ip)
 438               	.LM31:
 439 0006 2081      		ld r18,Z
 440 0008 3181      		ldd r19,Z+1
 441 000a 4281      		ldd r20,Z+2
 442 000c 5381      		ldd r21,Z+3
 443 000e 2617      		cp r18,r22
 444 0010 3707      		cpc r19,r23
 445 0012 4807      		cpc r20,r24
 446 0014 5907      		cpc r21,r25
 447 0016 01F0      		breq .L19
 220:stack.c       **** 	for (unsigned char b = 0;b<MAX_ARP_ENTRY;b++)
 449               	.LM32:
 450 0018 AF5F      		subi r26,lo8(-(1))
 451 001a 3A96      		adiw r30,10
 452 001c A530      		cpi r26,lo8(5)
 453 001e 01F4      		brne .L20
 454               	.L19:
 455               	.LBE11:
 223:stack.c       **** 		{
 224:stack.c       **** 			return(b);
 225:stack.c       **** 		}
 226:stack.c       **** 	}
 227:stack.c       **** 	return (MAX_ARP_ENTRY);
 228:stack.c       **** }
 457               	.LM33:
 458 0020 8A2F      		mov r24,r26
 459               	/* epilogue start */
 460 0022 0895      		ret
 465               	.Lscope3:
 467               		.stabd	78,0,0
 468               		.section	.text.new_eth_header,"ax",@progbits
 471               	.global	new_eth_header
 473               	new_eth_header:
 474               		.stabd	46,0,0
 229:stack.c       **** 
 230:stack.c       **** //----------------------------------------------------------------------------
 231:stack.c       **** //Diese Routine Erzeugt ein neuen Ethernetheader
 232:stack.c       **** void new_eth_header (unsigned char *buffer,unsigned long dest_ip)
 233:stack.c       **** {
 476               	.LM34:
 477               	.LFBB4:
 478 0000 EF92      		push r14
 479 0002 FF92      		push r15
 480 0004 0F93      		push r16
 481 0006 1F93      		push r17
 482 0008 CF93      		push r28
 483 000a DF93      		push r29
 484               	/* prologue: function */
 485               	/* frame size = 0 */
 486               	/* stack size = 6 */
 487               	.L__stack_usage = 6
 488 000c 8C01      		movw r16,r24
 489 000e CB01      		movw r24,r22
 490 0010 BA01      		movw r22,r20
 234:stack.c       **** 	struct Ethernet_Header *ethernet;
 235:stack.c       **** 	ethernet = (struct Ethernet_Header *)&buffer[ETHER_OFFSET];
 236:stack.c       **** 
 237:stack.c       **** 	unsigned char b = arp_entry_search (dest_ip);
 492               	.LM35:
 493 0012 0E94 0000 		call arp_entry_search
 238:stack.c       **** 
 239:stack.c       **** 	if (b != MAX_ARP_ENTRY) //Eintrag gefunden wenn ungleich
 495               	.LM36:
 496 0016 8530      		cpi r24,lo8(5)
 497 0018 01F0      		breq .L23
 232:stack.c       **** void new_eth_header (unsigned char *buffer,unsigned long dest_ip)
 499               	.LM37:
 500 001a 282F      		mov r18,r24
 501 001c 30E0      		ldi r19,lo8(0)
 502 001e F901      		movw r30,r18
 503 0020 EE0F      		lsl r30
 504 0022 FF1F      		rol r31
 505 0024 43E0      		ldi r20,3
 506 0026 220F      	1:	lsl r18
 507 0028 331F      		rol r19
 508 002a 4A95      		dec r20
 509 002c 01F4      		brne 1b
 510 002e E20F      		add r30,r18
 511 0030 F31F      		adc r31,r19
 512 0032 E050      		subi r30,lo8(-(arp_entry))
 513 0034 F040      		sbci r31,hi8(-(arp_entry))
 515               	.LM38:
 516 0036 E02E      		mov r14,r16
 517 0038 E701      		movw r28,r14
 518 003a 7E01      		movw r14,r28
 519 003c F12E      		mov r15,r17
 520 003e E701      		movw r28,r14
 521 0040 A0E0      		ldi r26,lo8(mymac)
 522 0042 B0E0      		ldi r27,hi8(mymac)
 523               	.L24:
 524               	.LBB12:
 240:stack.c       **** 	{
 241:stack.c       **** 		for(unsigned char a = 0; a < 6; a++)
 242:stack.c       **** 		{
 243:stack.c       **** 			//MAC Destadresse wird geschrieben mit MAC Sourceadresse
 244:stack.c       **** 			ethernet->EnetPacketDest[a] = arp_entry[b].arp_t_mac[a];
 526               	.LM39:
 527 0044 8191      		ld r24,Z+
 528 0046 8993      		st Y+,r24
 245:stack.c       **** 			//Meine MAC Adresse wird in Sourceadresse geschrieben
 246:stack.c       **** 			ethernet->EnetPacketSrc[a] = mymac[a];
 530               	.LM40:
 531 0048 8D91      		ld r24,X+
 532 004a 8D83      		std Y+5,r24
 241:stack.c       **** 		for(unsigned char a = 0; a < 6; a++)
 534               	.LM41:
 535 004c 30E0      		ldi r19,hi8(mymac+6)
 536 004e A030      		cpi r26,lo8(mymac+6)
 537 0050 B307      		cpc r27,r19
 538 0052 01F4      		brne .L24
 539 0054 00C0      		rjmp .L22
 540               	.L23:
 241:stack.c       **** 		for(unsigned char a = 0; a < 6; a++)
 542               	.LM42:
 543 0056 A02F      		mov r26,r16
 544 0058 B12F      		mov r27,r17
 545 005a E0E0      		ldi r30,lo8(mymac)
 546 005c F0E0      		ldi r31,hi8(mymac)
 547               	.LBE12:
 548               	.LBB13:
 247:stack.c       **** 		}
 248:stack.c       **** 		return;
 249:stack.c       **** 	}
 250:stack.c       **** 	DEBUG("No ARP entry found\r\n");
 251:stack.c       **** 
 252:stack.c       **** 	for(unsigned char a = 0; a < 6; a++)
 253:stack.c       **** 	{
 254:stack.c       **** 		//MAC Destadresse wird geschrieben mit MAC Sourceadresse
 255:stack.c       **** 		ethernet->EnetPacketDest[a] = 0xFF;
 550               	.LM43:
 551 005e 8FEF      		ldi r24,lo8(-1)
 552               	.L26:
 554               	.LM44:
 555 0060 8D93      		st X+,r24
 256:stack.c       **** 		//Meine MAC Adresse wird in Sourceadresse geschrieben
 257:stack.c       **** 		ethernet->EnetPacketSrc[a] = mymac[a];
 557               	.LM45:
 558 0062 9191      		ld r25,Z+
 559 0064 1596      		adiw r26,5
 560 0066 9C93      		st X,r25
 561 0068 1597      		sbiw r26,5
 252:stack.c       **** 	for(unsigned char a = 0; a < 6; a++)
 563               	.LM46:
 564 006a 90E0      		ldi r25,hi8(mymac+6)
 565 006c E030      		cpi r30,lo8(mymac+6)
 566 006e F907      		cpc r31,r25
 567 0070 01F4      		brne .L26
 568               	.L22:
 569               	/* epilogue start */
 570               	.LBE13:
 258:stack.c       **** 	}
 259:stack.c       **** 	return;
 260:stack.c       **** 
 261:stack.c       **** }
 572               	.LM47:
 573 0072 DF91      		pop r29
 574 0074 CF91      		pop r28
 575 0076 1F91      		pop r17
 576 0078 0F91      		pop r16
 577 007a FF90      		pop r15
 578 007c EF90      		pop r14
 579 007e 0895      		ret
 584               	.Lscope4:
 586               		.stabd	78,0,0
 587               		.section	.text.arp_reply,"ax",@progbits
 589               	.global	arp_reply
 591               	arp_reply:
 592               		.stabd	46,0,0
 262:stack.c       **** 
 263:stack.c       **** //----------------------------------------------------------------------------
 264:stack.c       **** //Diese Routine Antwortet auf ein ARP Packet
 265:stack.c       **** void arp_reply (void)
 266:stack.c       **** {
 594               	.LM48:
 595               	.LFBB5:
 596 0000 EF92      		push r14
 597 0002 FF92      		push r15
 598 0004 0F93      		push r16
 599 0006 1F93      		push r17
 600 0008 CF93      		push r28
 601 000a DF93      		push r29
 602               	/* prologue: function */
 603               	/* frame size = 0 */
 604               	/* stack size = 6 */
 605               	.L__stack_usage = 6
 267:stack.c       **** 	struct Ethernet_Header *ethernet;
 268:stack.c       **** 	ethernet = (struct Ethernet_Header *)&eth_buffer[ETHER_OFFSET];
 269:stack.c       **** 
 270:stack.c       **** 	struct ARP_Header *arp;
 271:stack.c       **** 	arp = (struct ARP_Header *)&eth_buffer[ARP_OFFSET];
 607               	.LM49:
 608 000c C0E0      		ldi r28,lo8(eth_buffer+14)
 609 000e D0E0      		ldi r29,hi8(eth_buffer+14)
 272:stack.c       **** 
 273:stack.c       **** 	//2 Byte Hardware Typ: Enthält den Code für Ethernet
 274:stack.c       **** 	if(		arp->ARP_HWType == 0x0100 &&
 611               	.LM50:
 612 0010 8091 0000 		lds r24,eth_buffer+14
 613 0014 9091 0000 		lds r25,eth_buffer+14+1
 614 0018 21E0      		ldi r18,hi8(256)
 615 001a 8030      		cpi r24,lo8(256)
 616 001c 9207      		cpc r25,r18
 617 001e 01F0      		breq .+2
 618 0020 00C0      		rjmp .L29
 620               	.LM51:
 621 0022 8091 0000 		lds r24,eth_buffer+16
 622 0026 9091 0000 		lds r25,eth_buffer+16+1
 623 002a 8830      		cpi r24,8
 624 002c 9105      		cpc r25,__zero_reg__
 625 002e 01F0      		breq .+2
 626 0030 00C0      		rjmp .L29
 275:stack.c       **** 
 276:stack.c       **** 			//2 Byte Protokoll Typ: Enthält den Code für IP
 277:stack.c       **** 			arp->ARP_PRType == 0x0008  &&
 628               	.LM52:
 629 0032 8091 0000 		lds r24,eth_buffer+18
 630 0036 8630      		cpi r24,lo8(6)
 631 0038 01F0      		breq .+2
 632 003a 00C0      		rjmp .L29
 278:stack.c       **** 
 279:stack.c       **** 			//1Byte Länge der Hardwareadresse:Enthält 6 für 6 Byte MAC Addresse
 280:stack.c       **** 			arp->ARP_HWLen == 0x06 &&
 634               	.LM53:
 635 003c 8091 0000 		lds r24,eth_buffer+19
 636 0040 8430      		cpi r24,lo8(4)
 637 0042 01F0      		breq .+2
 638 0044 00C0      		rjmp .L29
 281:stack.c       **** 
 282:stack.c       **** 			//1Byte Länge der Protokolladresse:Enthält 4 für 4 Byte Adressen
 283:stack.c       **** 			arp->ARP_PRLen == 0x04 &&
 640               	.LM54:
 641 0046 2091 0000 		lds r18,eth_buffer+38
 642 004a 3091 0000 		lds r19,eth_buffer+38+1
 643 004e 4091 0000 		lds r20,eth_buffer+38+2
 644 0052 5091 0000 		lds r21,eth_buffer+38+3
 645 0056 8091 0000 		lds r24,myip
 646 005a 9091 0000 		lds r25,myip+1
 647 005e A091 0000 		lds r26,myip+2
 648 0062 B091 0000 		lds r27,myip+3
 649 0066 2817      		cp r18,r24
 650 0068 3907      		cpc r19,r25
 651 006a 4A07      		cpc r20,r26
 652 006c 5B07      		cpc r21,r27
 653 006e 01F0      		breq .+2
 654 0070 00C0      		rjmp .L29
 284:stack.c       **** 
 285:stack.c       **** 			//Ist das ARP Packet für meine IP Addresse bestimmt
 286:stack.c       **** 			//Vergleiche ARP Target IP Adresse mit meiner IP
 287:stack.c       **** 			arp->ARP_TIPAddr == *((unsigned long*)&myip[0]))
 288:stack.c       **** 	{
 289:stack.c       **** 		//Operation handelt es sich um eine anfrage
 290:stack.c       **** 		if (arp->ARP_Op == 0x0100)
 656               	.LM55:
 657 0072 8091 0000 		lds r24,eth_buffer+20
 658 0076 9091 0000 		lds r25,eth_buffer+20+1
 659 007a A1E0      		ldi r26,hi8(256)
 660 007c 8030      		cpi r24,lo8(256)
 661 007e 9A07      		cpc r25,r26
 662 0080 01F0      		breq .+2
 663 0082 00C0      		rjmp .L31
 664               	.LBB14:
 291:stack.c       **** 		{
 292:stack.c       **** 			//Rechner Eingetragen wenn noch nicht geschehen?
 293:stack.c       **** 			arp_entry_add();
 666               	.LM56:
 667 0084 0E94 0000 		call arp_entry_add
 294:stack.c       **** 
 295:stack.c       **** 			new_eth_header (eth_buffer, arp->ARP_SIPAddr); //Erzeugt ein neuen Ethernetheader
 669               	.LM57:
 670 0088 4091 0000 		lds r20,eth_buffer+28
 671 008c 5091 0000 		lds r21,eth_buffer+28+1
 672 0090 6091 0000 		lds r22,eth_buffer+28+2
 673 0094 7091 0000 		lds r23,eth_buffer+28+3
 674 0098 CE01      		movw r24,r28
 675 009a 0E97      		sbiw r24,14
 676 009c 0E94 0000 		call new_eth_header
 296:stack.c       **** 
 297:stack.c       **** 			ethernet->EnetPacketType = 0x0608; //Nutzlast 0x0800=IP Datagramm;0x0806 = ARP
 678               	.LM58:
 679 00a0 88E0      		ldi r24,lo8(1544)
 680 00a2 96E0      		ldi r25,hi8(1544)
 681 00a4 9093 0000 		sts eth_buffer+12+1,r25
 682 00a8 8093 0000 		sts eth_buffer+12,r24
 298:stack.c       **** 
 299:stack.c       **** 			unsigned char b = arp_entry_search (arp->ARP_SIPAddr);
 684               	.LM59:
 685 00ac E090 0000 		lds r14,eth_buffer+28
 686 00b0 F090 0000 		lds r15,eth_buffer+28+1
 687 00b4 0091 0000 		lds r16,eth_buffer+28+2
 688 00b8 1091 0000 		lds r17,eth_buffer+28+3
 689 00bc C801      		movw r24,r16
 690 00be B701      		movw r22,r14
 691 00c0 0E94 0000 		call arp_entry_search
 300:stack.c       **** 			if (b != MAX_ARP_ENTRY) //Eintrag gefunden wenn ungleich
 693               	.LM60:
 694 00c4 8530      		cpi r24,lo8(5)
 695 00c6 01F0      		breq .L32
 265:stack.c       **** void arp_reply (void)
 697               	.LM61:
 698 00c8 282F      		mov r18,r24
 699 00ca 30E0      		ldi r19,lo8(0)
 700 00cc F901      		movw r30,r18
 701 00ce EE0F      		lsl r30
 702 00d0 FF1F      		rol r31
 703 00d2 63E0      		ldi r22,3
 704 00d4 220F      	1:	lsl r18
 705 00d6 331F      		rol r19
 706 00d8 6A95      		dec r22
 707 00da 01F4      		brne 1b
 708 00dc E20F      		add r30,r18
 709 00de F31F      		adc r31,r19
 710 00e0 E050      		subi r30,lo8(-(arp_entry))
 711 00e2 F040      		sbci r31,hi8(-(arp_entry))
 713               	.LM62:
 714 00e4 80E0      		ldi r24,lo8(mymac)
 715 00e6 90E0      		ldi r25,hi8(mymac)
 265:stack.c       **** void arp_reply (void)
 717               	.LM63:
 718 00e8 AE01      		movw r20,r28
 719 00ea 485F      		subi r20,lo8(-(8))
 720 00ec 5F4F      		sbci r21,hi8(-(8))
 721               	.L33:
 722               	.LBB15:
 301:stack.c       **** 			{
 302:stack.c       **** 				for(unsigned char a = 0; a < 6; a++)
 303:stack.c       **** 				{
 304:stack.c       **** 					//ARP MAC Targetadresse wird geschrieben mit ARP Sourceadresse
 305:stack.c       **** 					arp->ARP_THAddr[a] = arp_entry[b].arp_t_mac[a];
 724               	.LM64:
 725 00ee 2191      		ld r18,Z+
 726 00f0 DA01      		movw r26,r20
 727 00f2 1A96      		adiw r26,10
 728 00f4 2C93      		st X,r18
 306:stack.c       **** 					//ARP MAC Sourceadresse wird geschrieben mit My MAC Adresse
 307:stack.c       **** 					arp->ARP_SHAddr[a] = mymac[a];
 730               	.LM65:
 731 00f6 DC01      		movw r26,r24
 732 00f8 2D91      		ld r18,X+
 733 00fa CD01      		movw r24,r26
 734 00fc DA01      		movw r26,r20
 735 00fe 2D93      		st X+,r18
 736 0100 AD01      		movw r20,r26
 302:stack.c       **** 				for(unsigned char a = 0; a < 6; a++)
 738               	.LM66:
 739 0102 B0E0      		ldi r27,hi8(mymac+6)
 740 0104 8030      		cpi r24,lo8(mymac+6)
 741 0106 9B07      		cpc r25,r27
 742 0108 01F4      		brne .L33
 743               	.L32:
 744               	.LBE15:
 308:stack.c       **** 				}
 309:stack.c       **** 			}
 310:stack.c       **** 			else
 311:stack.c       **** 			{
 312:stack.c       **** 				DEBUG("No ARP entry found\r\n");//Unwarscheinlich das das jemals passiert!
 313:stack.c       **** 			}
 314:stack.c       **** 
 315:stack.c       **** 			//ARP operation wird auf 2 gesetzt damit der andere merkt es ist ein ECHO
 316:stack.c       **** 			arp->ARP_Op = 0x0200;
 746               	.LM67:
 747 010a 80E0      		ldi r24,lo8(512)
 748 010c 92E0      		ldi r25,hi8(512)
 749 010e 9F83      		std Y+7,r25
 750 0110 8E83      		std Y+6,r24
 317:stack.c       **** 			//ARP Target IP Adresse wird geschrieben mit ARP Source IP Adresse
 318:stack.c       **** 			arp->ARP_TIPAddr = arp->ARP_SIPAddr;
 752               	.LM68:
 753 0112 E88E      		std Y+24,r14
 754 0114 F98E      		std Y+25,r15
 755 0116 0A8F      		std Y+26,r16
 756 0118 1B8F      		std Y+27,r17
 319:stack.c       **** 			//Meine IP Adresse wird in ARP Source IP Adresse geschrieben
 320:stack.c       **** 			arp->ARP_SIPAddr = *((unsigned long *)&myip[0]);
 758               	.LM69:
 759 011a 8091 0000 		lds r24,myip
 760 011e 9091 0000 		lds r25,myip+1
 761 0122 A091 0000 		lds r26,myip+2
 762 0126 B091 0000 		lds r27,myip+3
 763 012a 8E87      		std Y+14,r24
 764 012c 9F87      		std Y+15,r25
 765 012e A88B      		std Y+16,r26
 766 0130 B98B      		std Y+17,r27
 321:stack.c       **** 
 322:stack.c       **** 			//Nun ist das ARP-Packet fertig zum Senden !!!
 323:stack.c       **** 			//Sendet das erzeugte ARP Packet
 324:stack.c       **** 			ETH_PACKET_SEND(ARP_REPLY_LEN,eth_buffer);
 768               	.LM70:
 769 0132 8CE3      		ldi r24,lo8(60)
 770 0134 90E0      		ldi r25,hi8(60)
 771 0136 60E0      		ldi r22,lo8(eth_buffer)
 772 0138 70E0      		ldi r23,hi8(eth_buffer)
 773 013a 0E94 0000 		call enc28j60_send_packet
 325:stack.c       **** 			return;
 775               	.LM71:
 776 013e 00C0      		rjmp .L29
 777               	.L31:
 778               	.LBE14:
 326:stack.c       **** 		}
 327:stack.c       **** 		//es handelt sich um ein REPLY von einem anderen Client
 328:stack.c       **** 		if (arp->ARP_Op == 0x0200)
 780               	.LM72:
 781 0140 22E0      		ldi r18,hi8(512)
 782 0142 8030      		cpi r24,lo8(512)
 783 0144 9207      		cpc r25,r18
 784 0146 01F4      		brne .L29
 329:stack.c       **** 		{
 330:stack.c       **** 			//Rechner Eingetragen wenn noch nicht geschehen?
 331:stack.c       **** 			arp_entry_add();
 786               	.LM73:
 787 0148 0E94 0000 		call arp_entry_add
 788               	.L29:
 789               	/* epilogue start */
 332:stack.c       **** 
 333:stack.c       **** 			DEBUG("ARP REPLY!\r\n");
 334:stack.c       **** 		}
 335:stack.c       **** 	}
 336:stack.c       **** 	return;
 337:stack.c       **** }
 791               	.LM74:
 792 014c DF91      		pop r29
 793 014e CF91      		pop r28
 794 0150 1F91      		pop r17
 795 0152 0F91      		pop r16
 796 0154 FF90      		pop r15
 797 0156 EF90      		pop r14
 798 0158 0895      		ret
 806               	.Lscope5:
 808               		.stabd	78,0,0
 809               		.section	.text.checksum,"ax",@progbits
 814               	.global	checksum
 816               	checksum:
 817               		.stabd	46,0,0
 338:stack.c       **** 
 339:stack.c       **** //----------------------------------------------------------------------------
 340:stack.c       **** //Diese Routine erzeugt ein ARP Request
 341:stack.c       **** char arp_request (unsigned long dest_ip)
 342:stack.c       **** {
 343:stack.c       **** 	unsigned char buffer[ARP_REQUEST_LEN];
 344:stack.c       **** 	unsigned char index = 0;
 345:stack.c       **** 	unsigned long dest_ip_store;
 346:stack.c       **** 
 347:stack.c       **** 	struct Ethernet_Header *ethernet;
 348:stack.c       **** 	ethernet = (struct Ethernet_Header *)&buffer[ETHER_OFFSET];
 349:stack.c       **** 
 350:stack.c       **** 	struct ARP_Header *arp;
 351:stack.c       **** 	arp = (struct ARP_Header *)&buffer[ARP_OFFSET];
 352:stack.c       **** 
 353:stack.c       **** 	dest_ip_store = dest_ip;
 354:stack.c       **** 
 355:stack.c       **** 	//Nutzlast 0x0800=IP Datagramm;0x0806 = ARP
 356:stack.c       **** 	ethernet->EnetPacketType = 0x0608;
 357:stack.c       **** 
 358:stack.c       **** 	new_eth_header (buffer,dest_ip);
 359:stack.c       **** 
 360:stack.c       **** 	//Meine IP Adresse wird in ARP Source IP Adresse geschrieben
 361:stack.c       **** 	arp->ARP_SIPAddr = *((unsigned long *)&myip[0]);
 362:stack.c       **** 
 363:stack.c       **** 	//Ziel IP wird in Dest IP geschrieben
 364:stack.c       **** 	arp->ARP_TIPAddr = dest_ip;
 365:stack.c       **** 
 366:stack.c       **** 	for(unsigned char count = 0; count < 6; count++)
 367:stack.c       **** 	{
 368:stack.c       **** 		  arp->ARP_SHAddr[count] = mymac[count];
 369:stack.c       **** 		  arp->ARP_THAddr[count] = 0x00;
 370:stack.c       **** 	}
 371:stack.c       **** 
 372:stack.c       **** 	arp->ARP_HWType = 0x0100;
 373:stack.c       **** 	arp->ARP_PRType = 0x0008;
 374:stack.c       **** 	arp->ARP_HWLen 	= 0x06;
 375:stack.c       **** 	arp->ARP_PRLen 	= 0x04;
 376:stack.c       **** 	arp->ARP_Op 	= 0x0100;
 377:stack.c       **** 
 378:stack.c       **** 	//Nun ist das ARP-Packet fertig zum Senden !!!
 379:stack.c       **** 	//Sendet das erzeugte ARP Packet
 380:stack.c       **** 	ETH_PACKET_SEND(ARP_REQUEST_LEN, buffer);
 381:stack.c       **** 
 382:stack.c       **** 	for(unsigned char count = 0;count<20;count++)
 383:stack.c       **** 	{
 384:stack.c       **** 		unsigned char index_tmp = arp_entry_search(dest_ip_store);
 385:stack.c       **** 		index = arp_entry_search(dest_ip);
 386:stack.c       **** 		if (index < MAX_ARP_ENTRY || index_tmp < MAX_ARP_ENTRY)
 387:stack.c       **** 		{
 388:stack.c       **** //			DEBUG("ARP EINTRAG GEFUNDEN!\r\n");
 389:stack.c       **** 			if (index_tmp < MAX_ARP_ENTRY) return(1);//OK
 390:stack.c       **** 			arp_entry[index].arp_t_ip = dest_ip_store;
 391:stack.c       **** 			return(1);//OK
 392:stack.c       **** 		}
 393:stack.c       **** 		for(unsigned long a=0;a<10000;a++){asm volatile ("nop" ::);};
 394:stack.c       **** 		eth_get_data();
 395:stack.c       **** 		DEBUG("*No ARP entry found*\r\n");
 396:stack.c       **** 	}
 397:stack.c       **** 	return(0);//keine Antwort
 398:stack.c       **** }
 399:stack.c       **** 
 400:stack.c       **** #if USE_PING
 401:stack.c       **** //----------------------------------------------------------------------------
 402:stack.c       **** //Diese Routine erzeugt ein neues ICMP Packet
 403:stack.c       **** void icmp_send (unsigned long dest_ip, unsigned char icmp_type,
 404:stack.c       ****                 unsigned char icmp_code, unsigned int icmp_sn,
 405:stack.c       ****                 unsigned int icmp_id)
 406:stack.c       **** {
 407:stack.c       **** 	//Variablen zur Berechnung der Checksumme
 408:stack.c       **** 	unsigned int result16;
 409:stack.c       **** 
 410:stack.c       **** 	struct IP_Header *ip;
 411:stack.c       **** 	ip = (struct IP_Header *)&eth_buffer[IP_OFFSET];
 412:stack.c       **** 
 413:stack.c       **** 	struct ICMP_Header *icmp;
 414:stack.c       **** 	icmp = (struct ICMP_Header *)&eth_buffer[ICMP_OFFSET];
 415:stack.c       **** 
 416:stack.c       **** 	//Das ist ein Echo Reply Packet
 417:stack.c       **** 	icmp->ICMP_Type   = icmp_type;
 418:stack.c       **** 	icmp->ICMP_Code   = icmp_code;
 419:stack.c       **** 	icmp->ICMP_Id     = icmp_id;
 420:stack.c       **** 	icmp->ICMP_SeqNum = icmp_sn;
 421:stack.c       **** 
 422:stack.c       **** 	//Berechnung der ICMP Checksumme
 423:stack.c       **** 	//Alle Daten im ICMP Header werden addiert checksum wird deshalb
 424:stack.c       **** 	//ersteinmal auf null gesetzt
 425:stack.c       **** 	icmp->ICMP_Cksum = 0x0000;
 426:stack.c       **** 
 427:stack.c       **** 	//Hier wird erstmal der IP Header neu erstellt
 428:stack.c       **** 
 429:stack.c       **** 	ip->IP_Pktlen = 0x5400;                 // 0x54 = 84
 430:stack.c       ****  	ip->IP_Proto  = PROT_ICMP;
 431:stack.c       **** 	make_ip_header (eth_buffer,dest_ip);
 432:stack.c       **** 
 433:stack.c       **** 	//Berechnung der ICMP Header lÃ¤nge
 434:stack.c       **** 	result16 = LBBL_ENDIAN_INT(ip->IP_Pktlen);
 435:stack.c       **** 	result16 = result16 - ((ip->IP_Vers_Len & 0x0F) << 2);
 436:stack.c       **** 
 437:stack.c       **** 	//pointer wird auf das erste Packet im ICMP Header gesetzt
 438:stack.c       **** 	//jetzt wird die Checksumme berechnet
 439:stack.c       **** 	result16 = checksum (&icmp->ICMP_Type, result16, 0);
 440:stack.c       **** 
 441:stack.c       **** 	//schreibt Checksumme ins Packet
 442:stack.c       **** 	icmp->ICMP_Cksum = LBBL_ENDIAN_INT(result16);
 443:stack.c       **** 
 444:stack.c       **** 	//Sendet das erzeugte ICMP Packet
 445:stack.c       **** 
 446:stack.c       ****     ETH_PACKET_SEND(ICMP_REPLY_LEN,eth_buffer);
 447:stack.c       **** }
 448:stack.c       **** #endif
 449:stack.c       **** 
 450:stack.c       **** //----------------------------------------------------------------------------
 451:stack.c       **** //Diese Routine erzeugt eine Cecksumme
 452:stack.c       **** unsigned int checksum (unsigned char *pointer,unsigned int result16,unsigned long result32)
 453:stack.c       **** {
 819               	.LM75:
 820               	.LFBB6:
 821 0000 EF92      		push r14
 822 0002 FF92      		push r15
 823 0004 0F93      		push r16
 824 0006 1F93      		push r17
 825 0008 CF93      		push r28
 826 000a DF93      		push r29
 827               	/* prologue: function */
 828               	/* frame size = 0 */
 829               	/* stack size = 6 */
 830               	.L__stack_usage = 6
 831 000c 8C01      		movw r16,r24
 454:stack.c       **** 	unsigned int result16_1 = 0x0000;
 455:stack.c       **** 	unsigned char DataH;
 456:stack.c       **** 	unsigned char DataL;
 457:stack.c       **** 
 458:stack.c       **** 	//Jetzt werden alle Packete in einer While Schleife addiert
 459:stack.c       **** 	while(result16 > 1)
 833               	.LM76:
 834 000e EB01      		movw r28,r22
 835 0010 FC01      		movw r30,r24
 836 0012 00C0      		rjmp .L36
 837               	.L37:
 460:stack.c       **** 	{
 461:stack.c       **** 		//schreibt Inhalt Pointer nach DATAH danach inc Pointer
 462:stack.c       **** 		DataH=*pointer++;
 839               	.LM77:
 840 0014 9081      		ld r25,Z
 463:stack.c       **** 
 464:stack.c       **** 		//schreibt Inhalt Pointer nach DATAL danach inc Pointer
 465:stack.c       **** 		DataL=*pointer++;
 842               	.LM78:
 843 0016 8181      		ldd r24,Z+1
 452:stack.c       **** unsigned int checksum (unsigned char *pointer,unsigned int result16,unsigned long result32)
 845               	.LM79:
 846 0018 3296      		adiw r30,2
 466:stack.c       **** 
 467:stack.c       **** 		//erzeugt Int aus Data L und Data H
 468:stack.c       **** 		result16_1 = ((DataH << 8)+DataL);
 848               	.LM80:
 849 001a F92E      		mov r15,r25
 850 001c EE24      		clr r14
 851 001e D701      		movw r26,r14
 852 0020 A80F      		add r26,r24
 853 0022 B11D      		adc r27,__zero_reg__
 854 0024 CD01      		movw r24,r26
 469:stack.c       **** 		//Addiert packet mit vorherigen
 470:stack.c       **** 		result32 = result32 + result16_1;
 856               	.LM81:
 857 0026 A0E0      		ldi r26,lo8(0)
 858 0028 B0E0      		ldi r27,hi8(0)
 859 002a 280F      		add r18,r24
 860 002c 391F      		adc r19,r25
 861 002e 4A1F      		adc r20,r26
 862 0030 5B1F      		adc r21,r27
 471:stack.c       **** 		//decrimiert Länge von TCP Headerschleife um 2
 472:stack.c       **** 		result16 -=2;
 864               	.LM82:
 865 0032 2297      		sbiw r28,2
 866               	.L36:
 459:stack.c       **** 	while(result16 > 1)
 868               	.LM83:
 869 0034 C230      		cpi r28,2
 870 0036 D105      		cpc r29,__zero_reg__
 871 0038 00F4      		brsh .L37
 452:stack.c       **** unsigned int checksum (unsigned char *pointer,unsigned int result16,unsigned long result32)
 873               	.LM84:
 874 003a FB01      		movw r30,r22
 875 003c EE7F      		andi r30,lo8(-2)
 459:stack.c       **** 	while(result16 > 1)
 877               	.LM85:
 878 003e E00F      		add r30,r16
 879 0040 F11F      		adc r31,r17
 473:stack.c       **** 	}
 474:stack.c       **** 
 475:stack.c       **** 	//Ist der Wert result16 ungerade ist DataL = 0
 476:stack.c       **** 	if(result16 > 0)
 881               	.LM86:
 882 0042 60FF      		sbrs r22,0
 883 0044 00C0      		rjmp .L38
 477:stack.c       **** 	{
 478:stack.c       **** 		//schreibt Inhalt Pointer nach DATAH danach inc Pointer
 479:stack.c       **** 		DataH=*pointer;
 480:stack.c       **** 		//erzeugt Int aus Data L ist 0 (ist nicht in der Berechnung) und Data H
 481:stack.c       **** 		result16_1 = (DataH << 8);
 885               	.LM87:
 886 0046 9081      		ld r25,Z
 887 0048 80E0      		ldi r24,lo8(0)
 482:stack.c       **** 		//Addiert packet mit vorherigen
 483:stack.c       **** 		result32 = result32 + result16_1;
 889               	.LM88:
 890 004a A0E0      		ldi r26,lo8(0)
 891 004c B0E0      		ldi r27,hi8(0)
 892 004e 280F      		add r18,r24
 893 0050 391F      		adc r19,r25
 894 0052 4A1F      		adc r20,r26
 895 0054 5B1F      		adc r21,r27
 896               	.L38:
 484:stack.c       **** 	}
 485:stack.c       **** 
 486:stack.c       **** 	//Komplementbildung (addiert Long INT_H Byte mit Long INT L Byte)
 487:stack.c       **** 	result32 = ((result32 & 0x0000FFFF)+ ((result32 & 0xFFFF0000) >> 16));
 898               	.LM89:
 899 0056 DA01      		movw r26,r20
 900 0058 C901      		movw r24,r18
 901 005a A070      		andi r26,hlo8(65535)
 902 005c B070      		andi r27,hhi8(65535)
 903 005e 9A01      		movw r18,r20
 904 0060 4427      		clr r20
 905 0062 5527      		clr r21
 906 0064 280F      		add r18,r24
 907 0066 391F      		adc r19,r25
 908 0068 4A1F      		adc r20,r26
 909 006a 5B1F      		adc r21,r27
 488:stack.c       **** 	result32 = ((result32 & 0x0000FFFF)+ ((result32 & 0xFFFF0000) >> 16));
 911               	.LM90:
 912 006c DA01      		movw r26,r20
 913 006e C901      		movw r24,r18
 914 0070 A070      		andi r26,hlo8(65535)
 915 0072 B070      		andi r27,hhi8(65535)
 916 0074 9A01      		movw r18,r20
 917 0076 4427      		clr r20
 918 0078 5527      		clr r21
 919 007a 280F      		add r18,r24
 920 007c 391F      		adc r19,r25
 921 007e 4A1F      		adc r20,r26
 922 0080 5B1F      		adc r21,r27
 489:stack.c       **** 	result16 =~(result32 & 0x0000FFFF);
 924               	.LM91:
 925 0082 2095      		com r18
 926 0084 3095      		com r19
 490:stack.c       **** 
 491:stack.c       **** 	return (result16);
 492:stack.c       **** }
 928               	.LM92:
 929 0086 C901      		movw r24,r18
 930               	/* epilogue start */
 931 0088 DF91      		pop r29
 932 008a CF91      		pop r28
 933 008c 1F91      		pop r17
 934 008e 0F91      		pop r16
 935 0090 FF90      		pop r15
 936 0092 EF90      		pop r14
 937 0094 0895      		ret
 942               	.Lscope6:
 944               		.stabd	78,0,0
 945               		.section	.text.make_ip_header,"ax",@progbits
 949               	.global	make_ip_header
 951               	make_ip_header:
 952               		.stabd	46,0,0
 493:stack.c       **** 
 494:stack.c       **** //----------------------------------------------------------------------------
 495:stack.c       **** //Diese Routine erzeugt ein IP Packet
 496:stack.c       **** void make_ip_header (unsigned char *buffer,unsigned long dest_ip)
 497:stack.c       **** {
 954               	.LM93:
 955               	.LFBB7:
 956 0000 CF92      		push r12
 957 0002 DF92      		push r13
 958 0004 EF92      		push r14
 959 0006 FF92      		push r15
 960 0008 0F93      		push r16
 961 000a 1F93      		push r17
 962 000c CF93      		push r28
 963 000e DF93      		push r29
 964               	/* prologue: function */
 965               	/* frame size = 0 */
 966               	/* stack size = 8 */
 967               	.L__stack_usage = 8
 968 0010 8C01      		movw r16,r24
 969 0012 6A01      		movw r12,r20
 970 0014 7B01      		movw r14,r22
 498:stack.c       **** 
 499:stack.c       **** 	//------------------------------------------------------------------------
 500:stack.c       **** 	struct Ethernet_Header *ethernet;
 501:stack.c       **** 	ethernet = (struct Ethernet_Header *)&buffer[ETHER_OFFSET];
 502:stack.c       **** 	new_eth_header (buffer, dest_ip); //Erzeugt ein neuen Ethernetheader
 972               	.LM94:
 973 0016 0E94 0000 		call new_eth_header
 503:stack.c       **** 	ethernet->EnetPacketType = 0x0008; //Nutzlast 0x0800=IP
 975               	.LM95:
 976 001a 88E0      		ldi r24,lo8(8)
 977 001c 90E0      		ldi r25,hi8(8)
 978 001e F801      		movw r30,r16
 979 0020 9587      		std Z+13,r25
 980 0022 8487      		std Z+12,r24
 504:stack.c       **** 	struct IP_Header *ip;
 505:stack.c       **** 	//------------------------------------------------------------------------
 506:stack.c       **** 
 507:stack.c       **** 	//Variablen zur Berechnung der Checksumme
 508:stack.c       **** 	unsigned int result16;
 509:stack.c       **** 
 510:stack.c       **** 	ip = (struct IP_Header *)&buffer[IP_OFFSET];
 982               	.LM96:
 983 0024 E801      		movw r28,r16
 984 0026 2E96      		adiw r28,14
 511:stack.c       **** 
 512:stack.c       **** 	//don't fragment
 513:stack.c       **** 	ip->IP_Frag_Offset = 0x0040;
 986               	.LM97:
 987 0028 80E4      		ldi r24,lo8(64)
 988 002a 90E0      		ldi r25,hi8(64)
 989 002c 9F83      		std Y+7,r25
 990 002e 8E83      		std Y+6,r24
 514:stack.c       **** 
 515:stack.c       **** 	//max. hops
 516:stack.c       **** 	ip->IP_ttl = 128;
 992               	.LM98:
 993 0030 80E8      		ldi r24,lo8(-128)
 994 0032 8887      		std Y+8,r24
 517:stack.c       **** 	IP_id_counter++;
 996               	.LM99:
 997 0034 8091 0000 		lds r24,IP_id_counter
 998 0038 9091 0000 		lds r25,IP_id_counter+1
 999 003c 0196      		adiw r24,1
 1000 003e 9093 0000 		sts IP_id_counter+1,r25
 1001 0042 8093 0000 		sts IP_id_counter,r24
 518:stack.c       **** 	ip->IP_Id = LBBL_ENDIAN_INT(IP_id_counter);
 1003               	.LM100:
 1004 0046 9827      		eor r25,r24
 1005 0048 8927      		eor r24,r25
 1006 004a 9827      		eor r25,r24
 1007 004c 9D83      		std Y+5,r25
 1008 004e 8C83      		std Y+4,r24
 519:stack.c       **** 	ip->IP_Vers_Len = 0x45;	//4 BIT Die Versionsnummer von IP,
 1010               	.LM101:
 1011 0050 85E4      		ldi r24,lo8(69)
 1012 0052 8687      		std Z+14,r24
 520:stack.c       **** 							//meistens also 4 + 4Bit Headergröße
 521:stack.c       **** 	ip->IP_Tos = 0x00;
 1014               	.LM102:
 1015 0054 1982      		std Y+1,__zero_reg__
 522:stack.c       **** 
 523:stack.c       **** 	//unsigned int	IP_Pktlen;		//16 Bit Komplette Läng des IP Datagrams in Bytes
 524:stack.c       **** 	//unsigned char	IP_Proto;		//Zeigt das höherschichtige Protokoll an
 525:stack.c       **** 									//(TCP, UDP, ICMP)
 526:stack.c       **** 
 527:stack.c       **** 	//IP Destadresse wird geschrieben mit IP Sourceadresse
 528:stack.c       **** 	//das packet soll ja zurückgeschickt werden :-)
 529:stack.c       **** 	ip->IP_Destaddr	= dest_ip;
 1017               	.LM103:
 1018 0056 C88A      		std Y+16,r12
 1019 0058 D98A      		std Y+17,r13
 1020 005a EA8A      		std Y+18,r14
 1021 005c FB8A      		std Y+19,r15
 530:stack.c       **** 	ip->IP_Srcaddr	= *((unsigned long *)&myip[0]);
 1023               	.LM104:
 1024 005e 8091 0000 		lds r24,myip
 1025 0062 9091 0000 		lds r25,myip+1
 1026 0066 A091 0000 		lds r26,myip+2
 1027 006a B091 0000 		lds r27,myip+3
 1028 006e 8C87      		std Y+12,r24
 1029 0070 9D87      		std Y+13,r25
 1030 0072 AE87      		std Y+14,r26
 1031 0074 BF87      		std Y+15,r27
 531:stack.c       **** 
 532:stack.c       **** 	//Berechnung der IP Checksumme
 533:stack.c       **** 	//Alle Daten im IP Header werden addiert checksum wird deshalb
 534:stack.c       **** 	//ersteinmal auf null gesetzt
 535:stack.c       **** 	ip->IP_Hdr_Cksum = 0x0000;
 1033               	.LM105:
 1034 0076 1B86      		std Y+11,__zero_reg__
 1035 0078 1A86      		std Y+10,__zero_reg__
 536:stack.c       **** 
 537:stack.c       **** 	//Berechnung der IP Header länge
 538:stack.c       **** 	result16 = (ip->IP_Vers_Len & 0x0F) << 2;
 539:stack.c       **** 
 540:stack.c       **** 	//jetzt wird die Checksumme berechnet
 541:stack.c       **** 	result16 = checksum (&ip->IP_Vers_Len, result16, 0);
 1037               	.LM106:
 1038 007a CE01      		movw r24,r28
 1039 007c 64E1      		ldi r22,lo8(20)
 1040 007e 70E0      		ldi r23,hi8(20)
 1041 0080 20E0      		ldi r18,lo8(0)
 1042 0082 30E0      		ldi r19,hi8(0)
 1043 0084 A901      		movw r20,r18
 1044 0086 0E94 0000 		call checksum
 542:stack.c       **** 
 543:stack.c       **** 	//schreibt Checksumme ins Packet
 544:stack.c       **** 	ip->IP_Hdr_Cksum = LBBL_ENDIAN_INT(result16);
 1046               	.LM107:
 1047 008a 9827      		eor r25,r24
 1048 008c 8927      		eor r24,r25
 1049 008e 9827      		eor r25,r24
 1050 0090 9B87      		std Y+11,r25
 1051 0092 8A87      		std Y+10,r24
 1052               	/* epilogue start */
 545:stack.c       **** 	return;
 546:stack.c       **** }
 1054               	.LM108:
 1055 0094 DF91      		pop r29
 1056 0096 CF91      		pop r28
 1057 0098 1F91      		pop r17
 1058 009a 0F91      		pop r16
 1059 009c FF90      		pop r15
 1060 009e EF90      		pop r14
 1061 00a0 DF90      		pop r13
 1062 00a2 CF90      		pop r12
 1063 00a4 0895      		ret
 1068               	.Lscope7:
 1070               		.stabd	78,0,0
 1071               		.section	.text.udp_socket_process,"ax",@progbits
 1073               	.global	udp_socket_process
 1075               	udp_socket_process:
 1076               		.stabd	46,0,0
 547:stack.c       **** 
 548:stack.c       **** 
 549:stack.c       **** //----------------------------------------------------------------------------
 550:stack.c       **** //Diese Routine verwaltet die UDP Ports
 551:stack.c       **** void udp_socket_process(void)
 552:stack.c       **** {
 1078               	.LM109:
 1079               	.LFBB8:
 1080               	/* prologue: function */
 1081               	/* frame size = 0 */
 1082               	/* stack size = 0 */
 1083               	.L__stack_usage = 0
 553:stack.c       **** 	struct IP_Header *ip;
 554:stack.c       **** 	ip = (struct IP_Header *)&eth_buffer[IP_OFFSET];
 555:stack.c       **** 
 556:stack.c       **** 	struct UDP_Header *udp;
 557:stack.c       **** 	udp = (struct UDP_Header *)&eth_buffer[UDP_OFFSET];
 558:stack.c       **** 
 559:stack.c       **** 	//zugehörige Anwendung ausführen - hier immer der tftp-client
 560:stack.c       **** 	DEBUG("UDP Anwendung gefunden an Port %i, Src-Port %i!\r\n", LBBL_ENDIAN_INT(udp->udp_DestPort), L
 561:stack.c       **** 
 562:stack.c       **** 	tftp_get(ip->IP_Srcaddr, LBBL_ENDIAN_INT(udp->udp_SrcPort));
 1085               	.LM110:
 1086 0000 6091 0000 		lds r22,eth_buffer+26
 1087 0004 7091 0000 		lds r23,eth_buffer+26+1
 1088 0008 8091 0000 		lds r24,eth_buffer+26+2
 1089 000c 9091 0000 		lds r25,eth_buffer+26+3
 1090 0010 4091 0000 		lds r20,eth_buffer+34
 1091 0014 5091 0000 		lds r21,eth_buffer+34+1
 1092 0018 5427      		eor r21,r20
 1093 001a 4527      		eor r20,r21
 1094 001c 5427      		eor r21,r20
 1095 001e 0E94 0000 		call tftp_get
 1096               	/* epilogue start */
 563:stack.c       **** 	return;
 564:stack.c       **** }
 1098               	.LM111:
 1099 0022 0895      		ret
 1101               	.Lscope8:
 1103               		.stabd	78,0,0
 1104               		.section	.text.check_packet,"ax",@progbits
 1106               	.global	check_packet
 1108               	check_packet:
 1109               		.stabd	46,0,0
 101:stack.c       **** {
 1111               	.LM112:
 1112               	.LFBB9:
 1113               	/* prologue: function */
 1114               	/* frame size = 0 */
 1115               	/* stack size = 0 */
 1116               	.L__stack_usage = 0
 115:stack.c       **** 	if(ETHERNET_ARP_DATAGRAMM) {
 1118               	.LM113:
 1119 0000 8091 0000 		lds r24,eth_buffer+12
 1120 0004 9091 0000 		lds r25,eth_buffer+12+1
 1121 0008 26E0      		ldi r18,hi8(1544)
 1122 000a 8830      		cpi r24,lo8(1544)
 1123 000c 9207      		cpc r25,r18
 1124 000e 01F4      		brne .L42
 117:stack.c       **** 		arp_reply();
 1126               	.LM114:
 1127 0010 0E94 0000 		call arp_reply
 1128 0014 0895      		ret
 1129               	.L42:
 119:stack.c       **** 		if(ETHERNET_IP_DATAGRAMM && IF_MYIP) {
 1131               	.LM115:
 1132 0016 8830      		cpi r24,8
 1133 0018 9105      		cpc r25,__zero_reg__
 1134 001a 01F4      		brne .L41
 119:stack.c       **** 		if(ETHERNET_IP_DATAGRAMM && IF_MYIP) {
 1136               	.LM116:
 1137 001c 2091 0000 		lds r18,eth_buffer+30
 1138 0020 3091 0000 		lds r19,eth_buffer+30+1
 1139 0024 4091 0000 		lds r20,eth_buffer+30+2
 1140 0028 5091 0000 		lds r21,eth_buffer+30+3
 1141 002c 8091 0000 		lds r24,myip
 1142 0030 9091 0000 		lds r25,myip+1
 1143 0034 A091 0000 		lds r26,myip+2
 1144 0038 B091 0000 		lds r27,myip+3
 1145 003c 2817      		cp r18,r24
 1146 003e 3907      		cpc r19,r25
 1147 0040 4A07      		cpc r20,r26
 1148 0042 5B07      		cpc r21,r27
 1149 0044 01F4      		brne .L41
 120:stack.c       **** 			arp_entry_add();			//Refresh des ARP Eintrages
 1151               	.LM117:
 1152 0046 0E94 0000 		call arp_entry_add
 144:stack.c       **** 				if(IP_UDP_PACKET) udp_socket_process();
 1154               	.LM118:
 1155 004a 8091 0000 		lds r24,eth_buffer+23
 1156 004e 8131      		cpi r24,lo8(17)
 1157 0050 01F4      		brne .L41
 144:stack.c       **** 				if(IP_UDP_PACKET) udp_socket_process();
 1159               	.LM119:
 1160 0052 0E94 0000 		call udp_socket_process
 1161               	.L41:
 1162 0056 0895      		ret
 1164               	.Lscope9:
 1166               		.stabd	78,0,0
 1167               		.section	.text.eth_get_data,"ax",@progbits
 1169               	.global	eth_get_data
 1171               	eth_get_data:
 1172               		.stabd	46,0,0
  81:stack.c       **** {
 1174               	.LM120:
 1175               	.LFBB10:
 1176               	/* prologue: function */
 1177               	/* frame size = 0 */
 1178               	/* stack size = 0 */
 1179               	.L__stack_usage = 0
  84:stack.c       **** 	packet_lenght = ETH_PACKET_RECEIVE(MTU_SIZE,eth_buffer);
 1181               	.LM121:
 1182 0000 80EB      		ldi r24,lo8(1200)
 1183 0002 94E0      		ldi r25,hi8(1200)
 1184 0004 60E0      		ldi r22,lo8(eth_buffer)
 1185 0006 70E0      		ldi r23,hi8(eth_buffer)
 1186 0008 0E94 0000 		call enc28j60_receive_packet
  86:stack.c       **** 	if(packet_lenght > 0)
 1188               	.LM122:
 1189 000c 0097      		sbiw r24,0
 1190 000e 01F0      		breq .L44
  88:stack.c       **** 		packet_lenght = packet_lenght - 4;
 1192               	.LM123:
 1193 0010 0497      		sbiw r24,4
  89:stack.c       **** 		eth_buffer[packet_lenght+1] = 0;
 1195               	.LM124:
 1196 0012 FC01      		movw r30,r24
 1197 0014 E050      		subi r30,lo8(-(eth_buffer))
 1198 0016 F040      		sbci r31,hi8(-(eth_buffer))
 1199 0018 1182      		std Z+1,__zero_reg__
  90:stack.c       **** 		eth_len = packet_lenght;			// remember length for global access
 1201               	.LM125:
 1202 001a 9093 0000 		sts eth_len+1,r25
 1203 001e 8093 0000 		sts eth_len,r24
  91:stack.c       **** 		check_packet();
 1205               	.LM126:
 1206 0022 0E94 0000 		call check_packet
 1207               	.L44:
 1208 0026 0895      		ret
 1210               	.Lscope10:
 1212               		.stabd	78,0,0
 1213               		.section	.text.arp_request,"ax",@progbits
 1216               	.global	arp_request
 1218               	arp_request:
 1219               		.stabd	46,0,0
 342:stack.c       **** {
 1221               	.LM127:
 1222               	.LFBB11:
 1223 0000 CF92      		push r12
 1224 0002 DF92      		push r13
 1225 0004 EF92      		push r14
 1226 0006 FF92      		push r15
 1227 0008 0F93      		push r16
 1228 000a 1F93      		push r17
 1229 000c DF93      		push r29
 1230 000e CF93      		push r28
 1231 0010 CDB7      		in r28,__SP_L__
 1232 0012 DEB7      		in r29,__SP_H__
 1233 0014 AA97      		sbiw r28,42
 1234 0016 0FB6      		in __tmp_reg__,__SREG__
 1235 0018 F894      		cli
 1236 001a DEBF      		out __SP_H__,r29
 1237 001c 0FBE      		out __SREG__,__tmp_reg__
 1238 001e CDBF      		out __SP_L__,r28
 1239               	/* prologue: function */
 1240               	/* frame size = 42 */
 1241               	/* stack size = 50 */
 1242               	.L__stack_usage = 50
 1243 0020 6B01      		movw r12,r22
 1244 0022 7C01      		movw r14,r24
 351:stack.c       **** 	arp = (struct ARP_Header *)&buffer[ARP_OFFSET];
 1246               	.LM128:
 1247 0024 8E01      		movw r16,r28
 1248 0026 015F      		subi r16,lo8(-(15))
 1249 0028 1F4F      		sbci r17,hi8(-(15))
 356:stack.c       **** 	ethernet->EnetPacketType = 0x0608;
 1251               	.LM129:
 1252 002a 88E0      		ldi r24,lo8(1544)
 1253 002c 96E0      		ldi r25,hi8(1544)
 1254 002e 9E87      		std Y+14,r25
 1255 0030 8D87      		std Y+13,r24
 358:stack.c       **** 	new_eth_header (buffer,dest_ip);
 1257               	.LM130:
 1258 0032 CE01      		movw r24,r28
 1259 0034 0196      		adiw r24,1
 1260 0036 B701      		movw r22,r14
 1261 0038 A601      		movw r20,r12
 1262 003a 0E94 0000 		call new_eth_header
 361:stack.c       **** 	arp->ARP_SIPAddr = *((unsigned long *)&myip[0]);
 1264               	.LM131:
 1265 003e 8091 0000 		lds r24,myip
 1266 0042 9091 0000 		lds r25,myip+1
 1267 0046 A091 0000 		lds r26,myip+2
 1268 004a B091 0000 		lds r27,myip+3
 1269 004e F801      		movw r30,r16
 1270 0050 8687      		std Z+14,r24
 1271 0052 9787      		std Z+15,r25
 1272 0054 A08B      		std Z+16,r26
 1273 0056 B18B      		std Z+17,r27
 364:stack.c       **** 	arp->ARP_TIPAddr = dest_ip;
 1275               	.LM132:
 1276 0058 C08E      		std Z+24,r12
 1277 005a D18E      		std Z+25,r13
 1278 005c E28E      		std Z+26,r14
 1279 005e F38E      		std Z+27,r15
 1280 0060 A0E0      		ldi r26,lo8(mymac)
 1281 0062 B0E0      		ldi r27,hi8(mymac)
 341:stack.c       **** char arp_request (unsigned long dest_ip)
 1283               	.LM133:
 1284 0064 FE01      		movw r30,r28
 1285 0066 7796      		adiw r30,23
 1286               	.L47:
 1287               	.LBB16:
 368:stack.c       **** 		  arp->ARP_SHAddr[count] = mymac[count];
 1289               	.LM134:
 1290 0068 8D91      		ld r24,X+
 1291 006a 8193      		st Z+,r24
 369:stack.c       **** 		  arp->ARP_THAddr[count] = 0x00;
 1293               	.LM135:
 1294 006c 1186      		std Z+9,__zero_reg__
 366:stack.c       **** 	for(unsigned char count = 0; count < 6; count++)
 1296               	.LM136:
 1297 006e 20E0      		ldi r18,hi8(mymac+6)
 1298 0070 A030      		cpi r26,lo8(mymac+6)
 1299 0072 B207      		cpc r27,r18
 1300 0074 01F4      		brne .L47
 1301               	.LBE16:
 372:stack.c       **** 	arp->ARP_HWType = 0x0100;
 1303               	.LM137:
 1304 0076 80E0      		ldi r24,lo8(256)
 1305 0078 91E0      		ldi r25,hi8(256)
 1306 007a F801      		movw r30,r16
 1307 007c 9183      		std Z+1,r25
 1308 007e 8083      		st Z,r24
 373:stack.c       **** 	arp->ARP_PRType = 0x0008;
 1310               	.LM138:
 1311 0080 28E0      		ldi r18,lo8(8)
 1312 0082 30E0      		ldi r19,hi8(8)
 1313 0084 3383      		std Z+3,r19
 1314 0086 2283      		std Z+2,r18
 374:stack.c       **** 	arp->ARP_HWLen 	= 0x06;
 1316               	.LM139:
 1317 0088 26E0      		ldi r18,lo8(6)
 1318 008a 2483      		std Z+4,r18
 375:stack.c       **** 	arp->ARP_PRLen 	= 0x04;
 1320               	.LM140:
 1321 008c 24E0      		ldi r18,lo8(4)
 1322 008e 2583      		std Z+5,r18
 376:stack.c       **** 	arp->ARP_Op 	= 0x0100;
 1324               	.LM141:
 1325 0090 9783      		std Z+7,r25
 1326 0092 8683      		std Z+6,r24
 380:stack.c       **** 	ETH_PACKET_SEND(ARP_REQUEST_LEN, buffer);
 1328               	.LM142:
 1329 0094 8AE2      		ldi r24,lo8(42)
 1330 0096 90E0      		ldi r25,hi8(42)
 1331 0098 BE01      		movw r22,r28
 1332 009a 6F5F      		subi r22,lo8(-(1))
 1333 009c 7F4F      		sbci r23,hi8(-(1))
 1334 009e 0E94 0000 		call enc28j60_send_packet
 1335 00a2 04E1      		ldi r16,lo8(20)
 1336               	.L50:
 1337               	.LBB17:
 1338               	.LBB18:
 384:stack.c       **** 		unsigned char index_tmp = arp_entry_search(dest_ip_store);
 1340               	.LM143:
 1341 00a4 C701      		movw r24,r14
 1342 00a6 B601      		movw r22,r12
 1343 00a8 0E94 0000 		call arp_entry_search
 386:stack.c       **** 		if (index < MAX_ARP_ENTRY || index_tmp < MAX_ARP_ENTRY)
 1345               	.LM144:
 1346 00ac 8530      		cpi r24,lo8(5)
 1347 00ae 00F0      		brlo .L51
 386:stack.c       **** 		if (index < MAX_ARP_ENTRY || index_tmp < MAX_ARP_ENTRY)
 1349               	.LM145:
 1350 00b0 80E0      		ldi r24,lo8(0)
 1351 00b2 90E0      		ldi r25,hi8(0)
 1352               	.L49:
 1353               	.LBB19:
 393:stack.c       **** 		for(unsigned long a=0;a<10000;a++){asm volatile ("nop" ::);};
 1355               	.LM146:
 1356               	/* #APP */
 1357               	 ;  393 "stack.c" 1
 1358 00b4 0000      		nop
 1359               	 ;  0 "" 2
 1360               	/* #NOAPP */
 1361 00b6 0196      		adiw r24,1
 1362 00b8 F7E2      		ldi r31,hi8(10000)
 1363 00ba 8031      		cpi r24,lo8(10000)
 1364 00bc 9F07      		cpc r25,r31
 1365 00be 01F4      		brne .L49
 1366               	.LBE19:
 394:stack.c       **** 		eth_get_data();
 1368               	.LM147:
 1369 00c0 0E94 0000 		call eth_get_data
 1370 00c4 0150      		subi r16,lo8(-(-1))
 1371               	.LBE18:
 382:stack.c       **** 	for(unsigned char count = 0;count<20;count++)
 1373               	.LM148:
 1374 00c6 01F4      		brne .L50
 397:stack.c       **** 	return(0);//keine Antwort
 1376               	.LM149:
 1377 00c8 80E0      		ldi r24,lo8(0)
 1378 00ca 00C0      		rjmp .L48
 1379               	.L51:
 1380               	.LBB20:
 389:stack.c       **** 			if (index_tmp < MAX_ARP_ENTRY) return(1);//OK
 1382               	.LM150:
 1383 00cc 81E0      		ldi r24,lo8(1)
 1384               	.L48:
 1385               	/* epilogue start */
 1386               	.LBE20:
 1387               	.LBE17:
 398:stack.c       **** }
 1389               	.LM151:
 1390 00ce AA96      		adiw r28,42
 1391 00d0 0FB6      		in __tmp_reg__,__SREG__
 1392 00d2 F894      		cli
 1393 00d4 DEBF      		out __SP_H__,r29
 1394 00d6 0FBE      		out __SREG__,__tmp_reg__
 1395 00d8 CDBF      		out __SP_L__,r28
 1396 00da CF91      		pop r28
 1397 00dc DF91      		pop r29
 1398 00de 1F91      		pop r17
 1399 00e0 0F91      		pop r16
 1400 00e2 FF90      		pop r15
 1401 00e4 EF90      		pop r14
 1402 00e6 DF90      		pop r13
 1403 00e8 CF90      		pop r12
 1404 00ea 0895      		ret
 1410               	.Lscope11:
 1412               		.stabd	78,0,0
 1413               		.section	.text.create_new_udp_packet,"ax",@progbits
 1419               	.global	create_new_udp_packet
 1421               	create_new_udp_packet:
 1422               		.stabd	46,0,0
 565:stack.c       **** 
 566:stack.c       **** //----------------------------------------------------------------------------
 567:stack.c       **** //Diese Routine Erzeugt ein neues UDP Packet
 568:stack.c       **** void create_new_udp_packet(	unsigned int data_length,
 569:stack.c       **** 							unsigned int src_port,
 570:stack.c       **** 							unsigned int dest_port,
 571:stack.c       **** 							unsigned long dest_ip)
 572:stack.c       **** {
 1424               	.LM152:
 1425               	.LFBB12:
 1426 0000 CF92      		push r12
 1427 0002 DF92      		push r13
 1428 0004 EF92      		push r14
 1429 0006 FF92      		push r15
 1430 0008 0F93      		push r16
 1431 000a 1F93      		push r17
 1432 000c CF93      		push r28
 1433 000e DF93      		push r29
 1434               	/* prologue: function */
 1435               	/* frame size = 0 */
 1436               	/* stack size = 8 */
 1437               	.L__stack_usage = 8
 1438 0010 6C01      		movw r12,r24
 1439 0012 CB01      		movw r24,r22
 1440 0014 FA01      		movw r30,r20
 1441 0016 B901      		movw r22,r18
 1442 0018 A801      		movw r20,r16
 573:stack.c       **** 	DEBUG("UDP wird gesendet an %i.%i.%i.%i:%u, Len %u!\r\n", (int)(dest_ip&0xFF), (int)(dest_ip>>8&0x
 574:stack.c       ****     unsigned int result16;
 575:stack.c       **** 	unsigned long result32;
 576:stack.c       **** 
 577:stack.c       **** 	struct UDP_Header *udp;
 578:stack.c       **** 	udp = (struct UDP_Header *)&eth_buffer[UDP_OFFSET];
 1444               	.LM153:
 1445 001a C0E0      		ldi r28,lo8(eth_buffer)
 1446 001c D0E0      		ldi r29,hi8(eth_buffer)
 1447 001e B2E2      		ldi r27,lo8(34)
 1448 0020 EB2E      		mov r14,r27
 1449 0022 F12C      		mov r15,__zero_reg__
 1450 0024 EC0E      		add r14,r28
 1451 0026 FD1E      		adc r15,r29
 579:stack.c       **** 
 580:stack.c       **** 	struct IP_Header *ip;
 581:stack.c       **** 	ip = (struct IP_Header *)&eth_buffer[IP_OFFSET];
 1453               	.LM154:
 1454 0028 8E01      		movw r16,r28
 1455 002a 025F      		subi r16,lo8(-(14))
 1456 002c 1F4F      		sbci r17,hi8(-(14))
 582:stack.c       **** 
 583:stack.c       **** 	udp->udp_SrcPort = LBBL_ENDIAN_INT(src_port);
 1458               	.LM155:
 1459 002e 9827      		eor r25,r24
 1460 0030 8927      		eor r24,r25
 1461 0032 9827      		eor r25,r24
 1462 0034 9093 0000 		sts eth_buffer+34+1,r25
 1463 0038 8093 0000 		sts eth_buffer+34,r24
 584:stack.c       **** 	udp->udp_DestPort = LBBL_ENDIAN_INT(dest_port);
 1465               	.LM156:
 1466 003c 9E2F      		mov r25,r30
 1467 003e 8F2F      		mov r24,r31
 1468 0040 F701      		movw r30,r14
 1469 0042 9383      		std Z+3,r25
 1470 0044 8283      		std Z+2,r24
 585:stack.c       **** 
 586:stack.c       **** 	//UDP Packetlänge
 587:stack.c       **** 	data_length = UDP_HDR_LEN + data_length;
 1472               	.LM157:
 1473 0046 C601      		movw r24,r12
 1474 0048 0896      		adiw r24,8
 588:stack.c       **** 	udp->udp_Hdrlen = LBBL_ENDIAN_INT(data_length);
 1476               	.LM158:
 1477 004a 9827      		eor r25,r24
 1478 004c 8927      		eor r24,r25
 1479 004e 9827      		eor r25,r24
 1480 0050 9583      		std Z+5,r25
 1481 0052 8483      		std Z+4,r24
 589:stack.c       **** 	//IP Headerlänge + UDP Headerlänge
 590:stack.c       **** 	data_length = IP_VERS_LEN + data_length;
 1483               	.LM159:
 1484 0054 C601      		movw r24,r12
 1485 0056 4C96      		adiw r24,28
 591:stack.c       **** 	//Hier wird erstmal der IP Header neu erstellt
 592:stack.c       **** 	ip->IP_Pktlen = LBBL_ENDIAN_INT(data_length);
 1487               	.LM160:
 1488 0058 9827      		eor r25,r24
 1489 005a 8927      		eor r24,r25
 1490 005c 9827      		eor r25,r24
 1491 005e F801      		movw r30,r16
 1492 0060 9383      		std Z+3,r25
 1493 0062 8283      		std Z+2,r24
 593:stack.c       **** 	data_length += ETH_HDR_LEN;
 594:stack.c       **** 	ip->IP_Proto = PROT_UDP;
 1495               	.LM161:
 1496 0064 81E1      		ldi r24,lo8(17)
 1497 0066 8187      		std Z+9,r24
 595:stack.c       **** 	make_ip_header (eth_buffer,dest_ip);
 1499               	.LM162:
 1500 0068 CE01      		movw r24,r28
 1501 006a 0E94 0000 		call make_ip_header
 596:stack.c       **** 
 597:stack.c       **** 	//Alle Daten im UDP Header werden addiert checksum wird deshalb
 598:stack.c       **** 	//ersteinmal auf null gesetzt
 599:stack.c       **** 	udp->udp_Chksum = 0;
 1503               	.LM163:
 1504 006e F701      		movw r30,r14
 1505 0070 1782      		std Z+7,__zero_reg__
 1506 0072 1682      		std Z+6,__zero_reg__
 600:stack.c       **** 
 601:stack.c       **** 	//Berechnet Headerlänge und Addiert Pseudoheaderlänge 2XIP = 8
 602:stack.c       **** 	result16 = LBBL_ENDIAN_INT(ip->IP_Pktlen) + 8;
 1508               	.LM164:
 1509 0074 F801      		movw r30,r16
 1510 0076 6281      		ldd r22,Z+2
 1511 0078 7381      		ldd r23,Z+3
 1512 007a 7627      		eor r23,r22
 1513 007c 6727      		eor r22,r23
 1514 007e 7627      		eor r23,r22
 1515 0080 685F      		subi r22,lo8(-(8))
 1516 0082 7F4F      		sbci r23,hi8(-(8))
 603:stack.c       **** 	result16 = result16 - ((ip->IP_Vers_Len & 0x0F) << 2);
 1518               	.LM165:
 1519 0084 8091 0000 		lds r24,eth_buffer+14
 1520 0088 90E0      		ldi r25,lo8(0)
 1521 008a 8F70      		andi r24,lo8(15)
 1522 008c 9070      		andi r25,hi8(15)
 1523 008e 880F      		lsl r24
 1524 0090 991F      		rol r25
 1525 0092 880F      		lsl r24
 1526 0094 991F      		rol r25
 1527 0096 681B      		sub r22,r24
 1528 0098 790B      		sbc r23,r25
 604:stack.c       **** 	result32 = result16 + 0x09;
 1530               	.LM166:
 1531 009a 9B01      		movw r18,r22
 1532 009c 275F      		subi r18,lo8(-(9))
 1533 009e 3F4F      		sbci r19,hi8(-(9))
 1534 00a0 40E0      		ldi r20,lo8(0)
 1535 00a2 50E0      		ldi r21,hi8(0)
 605:stack.c       **** 
 606:stack.c       **** 	//Routine berechnet die Checksumme
 607:stack.c       **** 	result16 = checksum ((&ip->IP_Vers_Len+12), result16, result32);
 1537               	.LM167:
 1538 00a4 CE01      		movw r24,r28
 1539 00a6 4A96      		adiw r24,26
 1540 00a8 0E94 0000 		call checksum
 608:stack.c       **** 	udp->udp_Chksum = LBBL_ENDIAN_INT(result16);
 1542               	.LM168:
 1543 00ac 9827      		eor r25,r24
 1544 00ae 8927      		eor r24,r25
 1545 00b0 9827      		eor r25,r24
 1546 00b2 F701      		movw r30,r14
 1547 00b4 9783      		std Z+7,r25
 1548 00b6 8683      		std Z+6,r24
 609:stack.c       **** 
 610:stack.c       **** 	//Sendet das erzeugte UDP Packet
 611:stack.c       ****     ETH_PACKET_SEND(data_length,eth_buffer);
 1550               	.LM169:
 1551 00b8 C601      		movw r24,r12
 1552 00ba 8A96      		adiw r24,42
 1553 00bc BE01      		movw r22,r28
 1554 00be 0E94 0000 		call enc28j60_send_packet
 1555               	/* epilogue start */
 612:stack.c       **** 	return;
 613:stack.c       **** }
 1557               	.LM170:
 1558 00c2 DF91      		pop r29
 1559 00c4 CF91      		pop r28
 1560 00c6 1F91      		pop r17
 1561 00c8 0F91      		pop r16
 1562 00ca FF90      		pop r15
 1563 00cc EF90      		pop r14
 1564 00ce DF90      		pop r13
 1565 00d0 CF90      		pop r12
 1566 00d2 0895      		ret
 1573               	.Lscope12:
 1575               		.stabd	78,0,0
 1576               	.global	IP_id_counter
 1577               	.global	IP_id_counter
 1578               		.section .bss
 1581               	IP_id_counter:
 1582 0000 0000      		.skip 2,0
 1583               		.comm myip,4,1
 1584               		.comm eth_buffer,1201,1
 1585               		.comm eth_len,2,1
 1586               		.comm arp_entry,50,1
 1592               		.text
 1594               	.Letext0:
 1595               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 stack.c
     /tmp/ccXlI5HY.s:2      *ABS*:0000003f __SREG__
     /tmp/ccXlI5HY.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccXlI5HY.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccXlI5HY.s:5      *ABS*:00000034 __CCP__
     /tmp/ccXlI5HY.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccXlI5HY.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccXlI5HY.s:122    .text.stack_init:00000000 stack_init
                            *COM*:00000004 myip
                            *COM*:000004b1 eth_buffer
     /tmp/ccXlI5HY.s:177    .text.arp_entry_add:00000000 arp_entry_add
                            *COM*:00000032 arp_entry
     /tmp/ccXlI5HY.s:421    .text.arp_entry_search:00000000 arp_entry_search
     /tmp/ccXlI5HY.s:473    .text.new_eth_header:00000000 new_eth_header
     /tmp/ccXlI5HY.s:591    .text.arp_reply:00000000 arp_reply
     /tmp/ccXlI5HY.s:816    .text.checksum:00000000 checksum
     /tmp/ccXlI5HY.s:951    .text.make_ip_header:00000000 make_ip_header
     /tmp/ccXlI5HY.s:1581   .bss:00000000 IP_id_counter
     /tmp/ccXlI5HY.s:1075   .text.udp_socket_process:00000000 udp_socket_process
     /tmp/ccXlI5HY.s:1108   .text.check_packet:00000000 check_packet
     /tmp/ccXlI5HY.s:1171   .text.eth_get_data:00000000 eth_get_data
                            *COM*:00000002 eth_len
     /tmp/ccXlI5HY.s:1218   .text.arp_request:00000000 arp_request
     /tmp/ccXlI5HY.s:1421   .text.create_new_udp_packet:00000000 create_new_udp_packet

UNDEFINED SYMBOLS
timer_init
enc28j60_init
enc28j60_send_packet
mymac
tftp_get
enc28j60_receive_packet
__do_clear_bss
